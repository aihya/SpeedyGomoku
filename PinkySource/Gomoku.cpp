#include "Gomoku.hpp"



const Gomoku::t_patterns Gomoku::_attack_patterns = {
    {
        Gomoku::BLACK, {
            { 0b010101010100, Gomoku::WINNING_SCORE },
            { 0b010101010111, Gomoku::WINNING_SCORE },
            { 0b010101010110, Gomoku::WINNING_SCORE },
            { 0b000101010101, Gomoku::WINNING_SCORE },
            { 0b110101010101, Gomoku::WINNING_SCORE },
            { 0b100101010101, Gomoku::WINNING_SCORE },
            { 0b010101010101, Gomoku::WINNING_SCORE },
            { 0b000101010100, Gomoku::FREE_FOUR_SCORE },

            { 0b010101010000, Gomoku::FOUR_SCORE },
            { 0b010101010010, Gomoku::FOUR_SCORE },
            { 0b010101010011, Gomoku::FOUR_SCORE },
            { 0b000001010101, Gomoku::FOUR_SCORE },
            { 0b110001010101, Gomoku::FOUR_SCORE },
            { 0b100001010101, Gomoku::FOUR_SCORE },

// Free threes ----- generated by capture ---
            { 0b000101010000, Gomoku::FREE_SCORE },
            { 0b000001010100, Gomoku::FREE_SCORE },
            { 0b000101010010, Gomoku::FREE_SCORE },
            { 0b000101010011, Gomoku::FREE_SCORE },
            { 0b100001010100, Gomoku::FREE_SCORE },
            { 0b110001010100, Gomoku::FREE_SCORE },
            { 0b000101000100, Gomoku::FREE_SCORE },
// -------------------------------------------        
            { 0b000001010111, Gomoku::THREE_SCORE },
            { 0b000001010110, Gomoku::THREE_SCORE },
            { 0b110101010000, Gomoku::THREE_SCORE },
            { 0b100101010000, Gomoku::THREE_SCORE },

            { 0b000000000101, Gomoku::TWO_SCORE },
            { 0b000000010100, Gomoku::TWO_SCORE },
            { 0b000000010111, Gomoku::TWO_SCORE },
            { 0b000000010110, Gomoku::TWO_SCORE },
            { 0b010100000000, Gomoku::TWO_SCORE },
            { 0b000101000000, Gomoku::TWO_SCORE },
            { 0b110101000000, Gomoku::TWO_SCORE },
            { 0b100101000000, Gomoku::TWO_SCORE },

            { 0b000000000001, Gomoku::ONE_SCORE },
            { 0b110000000001, Gomoku::ONE_SCORE },
            { 0b100000000001, Gomoku::ONE_SCORE },
            { 0b000000000111, Gomoku::ONE_SCORE },
            { 0b000000000110, Gomoku::ONE_SCORE },
            { 0b010000000010, Gomoku::ONE_SCORE },
            { 0b010000000011, Gomoku::ONE_SCORE },
            { 0b110100000000, Gomoku::ONE_SCORE },
            { 0b100100000000, Gomoku::ONE_SCORE },
        }
    },
    {
        Gomoku::WHITE, {
            { 0b101010101000, Gomoku::WINNING_SCORE },
            { 0b101010101011, Gomoku::WINNING_SCORE },
            { 0b101010101001, Gomoku::WINNING_SCORE },
            { 0b001010101010, Gomoku::WINNING_SCORE },
            { 0b111010101010, Gomoku::WINNING_SCORE },
            { 0b011010101010, Gomoku::WINNING_SCORE },
            { 0b101010101010, Gomoku::WINNING_SCORE },
            { 0b001010101000, Gomoku::FREE_FOUR_SCORE },

            { 0b101010100000, Gomoku::FOUR_SCORE },
            { 0b101010100001, Gomoku::FOUR_SCORE },
            { 0b101010100011, Gomoku::FOUR_SCORE },
            { 0b000010101010, Gomoku::FOUR_SCORE },
            { 0b110010101010, Gomoku::FOUR_SCORE },
            { 0b010010101010, Gomoku::FOUR_SCORE },

// Free threes ----- generated by capture ---
            { 0b001010100000, Gomoku::FREE_SCORE },
            { 0b000010101000, Gomoku::FREE_SCORE },
            { 0b001010100001, Gomoku::FREE_SCORE },
            { 0b001010100011, Gomoku::FREE_SCORE },
            { 0b010010101000, Gomoku::FREE_SCORE },
            { 0b110010101000, Gomoku::FREE_SCORE },
            { 0b001010001000, Gomoku::FREE_SCORE },
// -------------------------------------------        
            { 0b000010101011, Gomoku::THREE_SCORE },
            { 0b000010101001, Gomoku::THREE_SCORE },
            { 0b111010100000, Gomoku::THREE_SCORE },
            { 0b011010100000, Gomoku::THREE_SCORE },

            { 0b000000001010, Gomoku::TWO_SCORE },
            { 0b000000101000, Gomoku::TWO_SCORE },
            { 0b000000101011, Gomoku::TWO_SCORE },
            { 0b000000101001, Gomoku::TWO_SCORE },
            { 0b101000000000, Gomoku::TWO_SCORE },
            { 0b001010000000, Gomoku::TWO_SCORE },
            { 0b111010000000, Gomoku::TWO_SCORE },
            { 0b011010000000, Gomoku::TWO_SCORE },

            { 0b000000000010, Gomoku::ONE_SCORE },
            { 0b110000000010, Gomoku::ONE_SCORE },
            { 0b010000000010, Gomoku::ONE_SCORE },
            { 0b000000001011, Gomoku::ONE_SCORE },
            { 0b000000001001, Gomoku::ONE_SCORE },
            { 0b100000000001, Gomoku::ONE_SCORE },
            { 0b100000000011, Gomoku::ONE_SCORE },
            { 0b111000000000, Gomoku::ONE_SCORE },
            { 0b011000000000, Gomoku::ONE_SCORE },
        },
    }
};

const Gomoku::t_patterns Gomoku::_defense_patterns = {
    {
        Gomoku::BLACK, {
            { 0b011010101011, Gomoku::WIN_BLOCK_SCORE},
            { 0b011010101001, Gomoku::WIN_BLOCK_SCORE},
            { 0b101001101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b011001101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b111001101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b001001101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010011010, Gomoku::WIN_BLOCK_SCORE},
            { 0b011010011010, Gomoku::WIN_BLOCK_SCORE},
            { 0b111010011010, Gomoku::WIN_BLOCK_SCORE},
            { 0b001010011010, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010100110, Gomoku::WIN_BLOCK_SCORE},
            { 0b011010100110, Gomoku::WIN_BLOCK_SCORE},
            { 0b111010100110, Gomoku::WIN_BLOCK_SCORE},
            { 0b001010100110, Gomoku::WIN_BLOCK_SCORE},
            { 0b110110101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b100110101000, Gomoku::WIN_BLOCK_SCORE},
            { 0b100110101011, Gomoku::WIN_BLOCK_SCORE},
            { 0b100110101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b100110101001, Gomoku::WIN_BLOCK_SCORE},
            { 0b111001101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b101001101000, Gomoku::WIN_BLOCK_SCORE},
            { 0b101001101011, Gomoku::WIN_BLOCK_SCORE},
            { 0b101001101010, Gomoku::WIN_BLOCK_SCORE},
            { 0b101001101001, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010011000, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010011011, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010011010, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010011001, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010100100, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010100111, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010100110, Gomoku::WIN_BLOCK_SCORE},
            { 0b101010100101, Gomoku::WIN_BLOCK_SCORE},

// Block Free threes ----- generated by capture ---
            { 0b011010100000, Gomoku::FREE_BLOCK_SCORE },
            { 0b001010100100, Gomoku::FREE_BLOCK_SCORE },
            { 0b000010101001, Gomoku::FREE_BLOCK_SCORE },
            { 0b000110101000, Gomoku::FREE_BLOCK_SCORE },
            { 0b011010100011, Gomoku::FREE_BLOCK_SCORE },
            { 0b011010100001, Gomoku::FREE_BLOCK_SCORE },
            { 0b010010101001, Gomoku::FREE_BLOCK_SCORE },
            { 0b110010101001, Gomoku::FREE_BLOCK_SCORE },
            { 0b001010011000, Gomoku::FREE_BLOCK_SCORE },

// ------------------------------------------------        

        }
    },
    {
        Gomoku::WHITE, {
            { 0b100101010111, Gomoku::WIN_BLOCK_SCORE},
            { 0b100101010110, Gomoku::WIN_BLOCK_SCORE},
            { 0b010110010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b100110010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b110110010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b000110010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101100101, Gomoku::WIN_BLOCK_SCORE},
            { 0b100101100101, Gomoku::WIN_BLOCK_SCORE},
            { 0b110101100101, Gomoku::WIN_BLOCK_SCORE},
            { 0b000101100101, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101011001, Gomoku::WIN_BLOCK_SCORE},
            { 0b100101011001, Gomoku::WIN_BLOCK_SCORE},
            { 0b110101011001, Gomoku::WIN_BLOCK_SCORE},
            { 0b000101011001, Gomoku::WIN_BLOCK_SCORE},
            { 0b111001010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b011001010100, Gomoku::WIN_BLOCK_SCORE},
            { 0b011001010111, Gomoku::WIN_BLOCK_SCORE},
            { 0b011001010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b011001010110, Gomoku::WIN_BLOCK_SCORE},
            { 0b110110010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b010110010100, Gomoku::WIN_BLOCK_SCORE},
            { 0b010110010111, Gomoku::WIN_BLOCK_SCORE},
            { 0b010110010101, Gomoku::WIN_BLOCK_SCORE},
            { 0b010110010110, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101100100, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101100111, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101100101, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101100110, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101011000, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101011011, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101011001, Gomoku::WIN_BLOCK_SCORE},
            { 0b010101011010, Gomoku::WIN_BLOCK_SCORE},

// Block Free threes ----- generated by capture ---
            { 0b100101010000, Gomoku::FREE_BLOCK_SCORE },
            { 0b000101011000, Gomoku::FREE_BLOCK_SCORE },
            { 0b000001010110, Gomoku::FREE_BLOCK_SCORE },
            { 0b001001010100, Gomoku::FREE_BLOCK_SCORE },
            { 0b100101010011, Gomoku::FREE_BLOCK_SCORE },
            { 0b100101010010, Gomoku::FREE_BLOCK_SCORE },
            { 0b100001010110, Gomoku::FREE_BLOCK_SCORE },
            { 0b110001010110, Gomoku::FREE_BLOCK_SCORE },
            { 0b000101100100, Gomoku::FREE_BLOCK_SCORE },
// ------------------------------------------------    
        }
    },
};

const Gomoku::t_patterns Gomoku::_capture_patterns
{
    {
        Gomoku::BLACK, {
            { 0b01101001, Gomoku::CAPTURE_SCORE },
        }
    },
    {
        Gomoku::WHITE, {
            { 0b10010110, Gomoku::CAPTURE_SCORE },
        },
    }
};

// const Gomoku::t_patterns Gomoku::_capture_patterns
// {
//     {
//         Gomoku::BLACK, {
//             { 0b011010010000, Gomoku::CAPTURE_SCORE},
//             { 0b011010011010, Gomoku::CAPTURE_SCORE},
//             { 0b011010010101, Gomoku::CAPTURE_SCORE},
//             { 0b011010011001, Gomoku::CAPTURE_SCORE},
//             { 0b011010010110, Gomoku::CAPTURE_SCORE},
//             { 0b011010011011, Gomoku::CAPTURE_SCORE},
//             { 0b011010010111, Gomoku::CAPTURE_SCORE},
//             { 0b000110100100, Gomoku::CAPTURE_SCORE},
//             { 0b100110100110, Gomoku::CAPTURE_SCORE},
//             { 0b100110100101, Gomoku::CAPTURE_SCORE},
//             { 0b010110100101, Gomoku::CAPTURE_SCORE},
//             { 0b010110100110, Gomoku::CAPTURE_SCORE},
//             { 0b100110100111, Gomoku::CAPTURE_SCORE},
//             { 0b010110100111, Gomoku::CAPTURE_SCORE},
//             { 0b110110100110, Gomoku::CAPTURE_SCORE},
//             { 0b110110100101, Gomoku::CAPTURE_SCORE},
//             { 0b000001101001, Gomoku::CAPTURE_SCORE},
//             { 0b101001101001, Gomoku::CAPTURE_SCORE},
//             { 0b010101101001, Gomoku::CAPTURE_SCORE},
//             { 0b011001101001, Gomoku::CAPTURE_SCORE},
//             { 0b100101101001, Gomoku::CAPTURE_SCORE},
//             { 0b110101101001, Gomoku::CAPTURE_SCORE},
//             { 0b111001101001, Gomoku::CAPTURE_SCORE},
//         }
//     },
//     {
//         Gomoku::WHITE, {
//             { 0b100101100000, Gomoku::CAPTURE_SCORE},
//             { 0b100101100101, Gomoku::CAPTURE_SCORE},
//             { 0b100101101010, Gomoku::CAPTURE_SCORE},
//             { 0b100101100110, Gomoku::CAPTURE_SCORE},
//             { 0b100101101001, Gomoku::CAPTURE_SCORE},
//             { 0b100101100111, Gomoku::CAPTURE_SCORE},
//             { 0b100101101011, Gomoku::CAPTURE_SCORE},
//             { 0b001001011000, Gomoku::CAPTURE_SCORE},
//             { 0b011001011001, Gomoku::CAPTURE_SCORE},
//             { 0b011001011010, Gomoku::CAPTURE_SCORE},
//             { 0b101001011010, Gomoku::CAPTURE_SCORE},
//             { 0b101001011001, Gomoku::CAPTURE_SCORE},
//             { 0b011001011011, Gomoku::CAPTURE_SCORE},
//             { 0b101001011011, Gomoku::CAPTURE_SCORE},
//             { 0b111001011001, Gomoku::CAPTURE_SCORE},
//             { 0b111001011010, Gomoku::CAPTURE_SCORE},
//             { 0b000010010110, Gomoku::CAPTURE_SCORE},
//             { 0b010110010110, Gomoku::CAPTURE_SCORE},
//             { 0b101010010110, Gomoku::CAPTURE_SCORE},
//             { 0b100110010110, Gomoku::CAPTURE_SCORE},
//             { 0b011010010110, Gomoku::CAPTURE_SCORE},
//             { 0b111010010110, Gomoku::CAPTURE_SCORE},
//             { 0b110110010110, Gomoku::CAPTURE_SCORE},
//         },
//     }
// };

const Gomoku::t_patterns Gomoku::_illegal_patterns
{
    {
        Gomoku::BLACK, {
            { 0b000101010000, Gomoku::ILLEGAL_SCORE },
            { 0b000001010100, Gomoku::ILLEGAL_SCORE },
            { 0b110001010100, Gomoku::ILLEGAL_SCORE },
            { 0b100001010100, Gomoku::ILLEGAL_SCORE },
            { 0b010001010100, Gomoku::ILLEGAL_SCORE },
            { 0b000101010011, Gomoku::ILLEGAL_SCORE },
            { 0b000101010010, Gomoku::ILLEGAL_SCORE },
            { 0b000101010001, Gomoku::ILLEGAL_SCORE },
            { 0b100101100000, Gomoku::ILLEGAL_SCORE },
            { 0b100101100101, Gomoku::ILLEGAL_SCORE },
            { 0b100101101010, Gomoku::ILLEGAL_SCORE },
            { 0b100101100110, Gomoku::ILLEGAL_SCORE },
            { 0b100101101001, Gomoku::ILLEGAL_SCORE },
            { 0b100101100111, Gomoku::ILLEGAL_SCORE },
            { 0b100101101011, Gomoku::ILLEGAL_SCORE },
            { 0b001001011000, Gomoku::ILLEGAL_SCORE },
            { 0b011001011001, Gomoku::ILLEGAL_SCORE },
            { 0b011001011010, Gomoku::ILLEGAL_SCORE },
            { 0b101001011010, Gomoku::ILLEGAL_SCORE },
            { 0b101001011001, Gomoku::ILLEGAL_SCORE },
            { 0b011001011011, Gomoku::ILLEGAL_SCORE },
            { 0b101001011011, Gomoku::ILLEGAL_SCORE },
            { 0b111001011001, Gomoku::ILLEGAL_SCORE },
            { 0b111001011010, Gomoku::ILLEGAL_SCORE },
            { 0b000010010110, Gomoku::ILLEGAL_SCORE },
            { 0b010110010110, Gomoku::ILLEGAL_SCORE },
            { 0b101010010110, Gomoku::ILLEGAL_SCORE },
            { 0b100110010110, Gomoku::ILLEGAL_SCORE },
            { 0b011010010110, Gomoku::ILLEGAL_SCORE },
            { 0b111010010110, Gomoku::ILLEGAL_SCORE },
            { 0b110110010110, Gomoku::ILLEGAL_SCORE },
            { 0b000100010100, Gomoku::ILLEGAL_SCORE },
            { 0b000101000100, Gomoku::ILLEGAL_SCORE }
        }
    },
    {
        Gomoku::WHITE, {
            { 0b001010100000, Gomoku::ILLEGAL_SCORE },
            { 0b000010101000, Gomoku::ILLEGAL_SCORE },
            { 0b110010101000, Gomoku::ILLEGAL_SCORE },
            { 0b010010101000, Gomoku::ILLEGAL_SCORE },
            { 0b100010101000, Gomoku::ILLEGAL_SCORE },
            { 0b001010100011, Gomoku::ILLEGAL_SCORE },
            { 0b001010100001, Gomoku::ILLEGAL_SCORE },
            { 0b001010100010, Gomoku::ILLEGAL_SCORE },
            { 0b011010010000, Gomoku::ILLEGAL_SCORE },
            { 0b011010011010, Gomoku::ILLEGAL_SCORE },
            { 0b011010010101, Gomoku::ILLEGAL_SCORE },
            { 0b011010011001, Gomoku::ILLEGAL_SCORE },
            { 0b011010010110, Gomoku::ILLEGAL_SCORE },
            { 0b011010011011, Gomoku::ILLEGAL_SCORE },
            { 0b011010010111, Gomoku::ILLEGAL_SCORE },
            { 0b000110100100, Gomoku::ILLEGAL_SCORE },
            { 0b100110100110, Gomoku::ILLEGAL_SCORE },
            { 0b100110100101, Gomoku::ILLEGAL_SCORE },
            { 0b010110100101, Gomoku::ILLEGAL_SCORE },
            { 0b010110100110, Gomoku::ILLEGAL_SCORE },
            { 0b100110100111, Gomoku::ILLEGAL_SCORE },
            { 0b010110100111, Gomoku::ILLEGAL_SCORE },
            { 0b110110100110, Gomoku::ILLEGAL_SCORE },
            { 0b110110100101, Gomoku::ILLEGAL_SCORE },
            { 0b000001101001, Gomoku::ILLEGAL_SCORE },
            { 0b101001101001, Gomoku::ILLEGAL_SCORE },
            { 0b010101101001, Gomoku::ILLEGAL_SCORE },
            { 0b011001101001, Gomoku::ILLEGAL_SCORE },
            { 0b100101101001, Gomoku::ILLEGAL_SCORE },
            { 0b110101101001, Gomoku::ILLEGAL_SCORE },
            { 0b111001101001, Gomoku::ILLEGAL_SCORE },
            { 0b001000101000, Gomoku::ILLEGAL_SCORE },
            { 0b001010001000, Gomoku::ILLEGAL_SCORE }
        },
    }
};

const std::array<Gomoku::t_coord, 4> Gomoku::_directions {{
    {0, -1},
    {-1, 0},
    {1, -1},
    {1, 1}
}};

const std::vector<Gomoku::t_coord> Gomoku::_moveset_cells {
    {0, -1},
    {0, 1},
    {-1, 0},
    {1, 0},
    {1, -1},
    {-1, 1},
    {1, 1},
    {-1, -1},
};

uint64_t *Gomoku::copy_board(uint64_t *board)
{
    uint64_t *board_copy;

    board_copy = new uint64_t[this->_board_size]();
    for (short i = 0; i < this->_board_size; i++)
        board_copy[i] = board[i];
    return (board_copy);
}

inline void Gomoku::add_board_piece(uint64_t *board, t_coord piece_coord, t_piece piece)
{
    board[piece_coord.y] |= uint64_t(piece) << (piece_coord.x * 2);
}

inline void    Gomoku::remove_board_piece(uint64_t* board, t_coord piece_coord)
{
    board[piece_coord.y] &= ~((uint64_t)(Gomoku::ERROR) << (piece_coord.x << 1));
}

void    Gomoku::update_board(uint64_t *board, const t_update_list &update_list)
{
    for (auto &piece : update_list)
    {
        if (piece.type == Gomoku::ADD)
            this->add_board_piece(board, piece.coord, piece.piece);
        if (piece.type == Gomoku::REMOVE)
            this->remove_board_piece(board, piece.coord);
    }
}

void Gomoku::revert_board_update(uint64_t *board, const t_update_list &update_list)
{
    for (auto &piece : update_list)
    {
        if (piece.type == Gomoku::ADD)
            this->remove_board_piece(board, piece.coord);
        if (piece.type == Gomoku::REMOVE)
            this->add_board_piece(board, piece.coord, piece.piece);
    }
}

void Gomoku::print_board()
{
    this->print_board(this->_move_history.front(), this->_ai_moveset);
}

void Gomoku::print_board(uint64_t *board, t_moveset &moveset)
{
    for (short y = 0; y < this->_board_size; y++)
    {
        for (short x = 0; x < this->_board_size; x++)
        {
            t_coord current_move = {x, y};
            t_piece piece = this->get_piece(board, current_move);
            switch (piece)
            {
                
                case Gomoku::BLACK:
                    if (current_move.x == this->_last_move.x && current_move.y == this->_last_move.y)
                        std::cout << "\033[1;32mX \033[0m";
                    else
                        std::cout << "X ";
                    break;
                case Gomoku::WHITE:
                    if (current_move.x == this->_last_move.x && current_move.y == this->_last_move.y)
                        std::cout << "\033[1;32mO \033[0m";
                    else
                        std::cout << "O ";
                    break;
                case Gomoku::EMPTY:
                    if (moveset.count((t_coord){x, y}))
                        std::cout << "\033[1;31m. \033[0m";
                    else
                        std::cout << ". ";
                    break;
                default:
                    std::cout << "? ";
                    break;
            }
        }
        if (y < 10) std::cout << "0";
        std::cout << y << " ";
        std::cout << std::endl;
    }
    for (short y = 0; y < this->_board_size; y++)
        std::cout << (char)('A' + y) << " ";
    std::cout << std::endl;
}

Gomoku::t_player Gomoku::get_player(t_player_type player_type,
                                        t_piece player_color, t_difficulty difficulty)
{
    t_player player;

    memset(&player, 0, sizeof(t_player));
    player.piece = player_color;
    if (player_type == Gomoku::HUMAN)
        player.move = &Gomoku::human_move;
    else if (player_type == Gomoku::AI)
    {
        player.move = &Gomoku::ai_move;
        player.difficulty = difficulty;
    }
    return player;
}

Gomoku::Gomoku(uint8_t board_size, t_difficulty first_difficulty,
    t_difficulty second_difficulty, t_player_type first_player_type, t_player_type second_player_type)
{
    if (board_size < 5 || board_size > 19)
        throw std::invalid_argument("Board size must be between 5 and 19");
    this->_board_size = board_size;
    this->_turn = 0;
    this->_move_history.push_front(new uint64_t[board_size]());
    this->_first_player  = get_player(first_player_type, Gomoku::BLACK, first_difficulty);
    this->_second_player = get_player(second_player_type, Gomoku::WHITE, second_difficulty);
    this->_depth = 5;
    this->_average_time = 0;
}

Gomoku::~Gomoku()
{
    for (auto board : this->_move_history)
        delete[] board;
}

inline Gomoku::t_piece Gomoku::get_piece(uint64_t *board, t_coord piece_coord)
{
    if (piece_coord.y < 0 || piece_coord.y >= this->_board_size
            || piece_coord.x < 0 || piece_coord.x >= this->_board_size)
        return (Gomoku::ERROR);
    return (t_piece((board[piece_coord.y] >> (piece_coord.x * 2)) & 0b11));
}

bool    Gomoku::is_move_valid(t_coord piece_coord, t_piece piece)
{
    uint64_t *board = this->_move_history.front();
    int32_t score = 0;

    if (this->get_piece(board, piece_coord) != Gomoku::EMPTY)
        return (false);
    this->add_board_piece(board, piece_coord, piece);
    for (auto &dir: Gomoku::_directions)
    {
        score = this->evaluate_special_pattern(board, piece_coord, piece, dir);
        if (score == Gomoku::ILLEGAL_SCORE)
            break;
    }
    this->remove_board_piece(board, piece_coord);
    return (score != Gomoku::ILLEGAL_SCORE);
}

int32_t Gomoku::evaluate_dir(uint64_t *board, t_coord piece_coord, t_piece piece, t_coord direction)
{
    int32_t                                 attack_score;
    int32_t                                 defense_score;
    uint16_t                                current_pattern;
    uint16_t                                initial_pattern;
    t_piece                                 current_piece;
    t_coord                                 pattern_position;
    const std::map<uint16_t, t_scores>      &attack_patterns  = Gomoku::_attack_patterns.at(piece);
    const std::map<uint16_t, t_scores>      &defense_patterns  = Gomoku::_defense_patterns.at(piece);

    attack_score = 0;
    defense_score = 0;
    current_pattern = 0;
    pattern_position = piece_coord + direction;
    for (int j = 0; j < 5; j++)
    {
        current_pattern <<= 2;
        current_pattern |= this->get_piece(board, pattern_position);
        pattern_position += direction;
    }
    for (int i = 0; i < 6; i++)
    {
        current_piece = this->get_piece(board, piece_coord);
        current_pattern = ((uint16_t)(current_piece) << 10 | current_pattern);
        if (attack_patterns.count(current_pattern))
            attack_score = std::max(int32_t(attack_patterns.at(current_pattern)), attack_score);
        if (defense_patterns.count(current_pattern))
            defense_score = std::max(int32_t(defense_patterns.at(current_pattern)), defense_score);
        piece_coord -= direction;
        current_pattern >>= 2;
    }
    return (attack_score + defense_score);
}

int32_t Gomoku::evaluate_move(uint64_t *board, t_coord piece_coord, t_piece piece)
{
    int32_t score = 0;

    for (auto& dir: this->_directions)
        score += this->evaluate_dir(board, piece_coord, piece, dir);
    return (score);
}

int64_t Gomoku::evaluate_board(uint64_t *board, t_piece player_color)
{
    int64_t     score;
    t_coord     piece_coord;
    t_piece     piece;
    uint64_t    line;

    score = 0;
    for (piece_coord.y = 0; piece_coord.y < this->_board_size; piece_coord.y++)
    {
        line = board[piece_coord.y];
        do {
            if (line == 0)
                break;
            piece_coord.x = (__builtin_ffsll(line) - 1) >> 1;
            line &= ~((uint64_t)(Gomoku::ERROR) << (piece_coord.x << 1));
            piece = this->get_piece(board, piece_coord);
            if (piece == player_color)
                score += this->evaluate_move(board, piece_coord, piece);
            else
                score -= this->evaluate_move(board, piece_coord, piece);
        } while (piece_coord.x < this->_board_size);
    }

    return (score);
}

int64_t Gomoku::evaluate_board(t_moveset &moveset, uint64_t *board,  t_piece player_color, t_capture_count capture_count)
{
    int score;

    score = 0;
    for (const auto& move: moveset)
    {
        add_board_piece(board, move, player_color);
        score += evaluate_move(board, move, player_color);
        remove_board_piece(board, move);
        add_board_piece(board, move, GET_OPPONENT(player_color));
        score -= evaluate_move(board, move, GET_OPPONENT(player_color));
        remove_board_piece(board, move);
    }
    return (score);
}


bool Gomoku::is_winning_move(uint64_t* board, t_piece piece, t_coord move)
{
    return (this->evaluate_move(board, move, piece) >= Gomoku::WINNING_SCORE);
}

void Gomoku::extract_captured_stoned(uint64_t *board, t_update_list& update_list, t_coord move, t_coord dir, t_piece piece)
{
    t_coord        current_pos;
    t_coord        move_dir;
    uint16_t       current_pattern;

    for (auto& factor: {-1, 1})
    {
        move_dir = dir * factor;
        if (this->get_piece(board, move + move_dir) == GET_OPPONENT(piece) &&
            this->get_piece(board, move + (move_dir * 2)) == GET_OPPONENT(piece) &&
            this->get_piece(board, move + (move_dir * 3)) == piece)
        {
            update_list.push_back(t_move_update{move + move_dir, GET_OPPONENT(piece), Gomoku::REMOVE});
            update_list.push_back(t_move_update{move + move_dir * 2, GET_OPPONENT(piece), Gomoku::REMOVE});
        }
    }
}

int32_t Gomoku::evaluate_special_pattern(uint64_t *board, t_coord piece_coord, t_piece piece, t_coord direction)
{
    int32_t                             pattern_score;
    uint16_t                            current_pattern;
    t_piece                             current_piece;
    t_coord                             pattern_position;
    
    const std::map<uint16_t, t_scores>  &illegal_patterns  = Gomoku::_illegal_patterns.at(piece);
    const std::map<uint16_t, t_scores>  &capture_patterns  = Gomoku::_capture_patterns.at(piece);

    current_pattern = 0;
    pattern_score = Gomoku::ZERO_SCORE;
    pattern_position = piece_coord + direction;
    for (int j = 0; j < 5; j++)
    {
        current_pattern <<= 2;
        current_pattern |= this->get_piece(board, pattern_position);
        pattern_position += direction;
    }
    for (int i = 0; i < 6; i++)
    {
        current_pattern = (this->get_piece(board, piece_coord) << 10 | current_pattern);
        if (illegal_patterns.contains(current_pattern))
            return (Gomoku::ILLEGAL_SCORE);
        if (capture_patterns.contains(current_pattern & FOUR_MASK))
            pattern_score = Gomoku::CAPTURE_SCORE;
        current_pattern >>= 2;
        piece_coord -= direction;
    }
    return (pattern_score);
}

void Gomoku::print_patterns(uint64_t *board, t_coord piece_coord, t_piece piece, t_coord direction)
{
    uint16_t                            current_pattern;
    t_coord                             pattern_position;

    current_pattern = 0;
    pattern_position = piece_coord + direction;
    std::cout << "direction: " << "( " << direction.x << "," << direction.y << " )" << std::endl;
    for (int j = 0; j < 5; j++)
    {
        current_pattern <<= 2;
        current_pattern |= this->get_piece(board, pattern_position);
        pattern_position += direction;
    }
    for (int i = 0; i < 6; i++)
    {
        current_pattern = (this->get_piece(board, piece_coord) << 10 | current_pattern);
        std::cout << std::bitset<16>(current_pattern) << std::endl;
        current_pattern >>= 2;
        piece_coord -= direction;
    }
}

void Gomoku::generate_update_list(uint64_t* board, t_coord move, t_piece piece, t_update_list& update_list)
{
    int32_t         pattern_eval;
    uint16_t        current_pattern;

    this->add_board_piece(board, move, piece);
    for (auto& dir: this->_directions)
    {
        pattern_eval = this->evaluate_special_pattern(board, move, piece, dir);
        if (pattern_eval == Gomoku::ILLEGAL_SCORE)
            break;
        if (pattern_eval == Gomoku::CAPTURE_SCORE)
            this->extract_captured_stoned(board, update_list, move, dir, piece);
    }
    this->remove_board_piece(board, move);
    if (pattern_eval == Gomoku::ILLEGAL_SCORE)
        update_list.clear();
    else
        update_list.push_back(t_move_update{move, piece, Gomoku::ADD});
}

Gomoku::t_sorted_updates Gomoku::generate_sorted_updates(t_moveset& moveset, uint64_t* board, t_piece piece)
{
    t_sorted_updates    sorted_updates;
    t_scored_update     scored_move;

    for (const auto& move: moveset)
    {
        scored_move = {0};
        scored_move.move.coord = move;
        this->generate_update_list(board, move, piece, scored_move.updates);
        if (scored_move.updates.empty())
            continue;
        scored_move.move.score = this->evaluate_move(board, move, piece);
        this->update_board(board, scored_move.updates);
        scored_move.move.score += this->evaluate_move(board, move, piece);
        for (const auto& update: scored_move.updates)
        {
            if (update.type == Gomoku::REMOVE)
            {
                scored_move.move.score += Gomoku::CAPTURE_SCORE;
                scored_move.cupture_count++;
            }
        }

        this->revert_board_update(board, scored_move.updates);
        sorted_updates.insert(scored_move);
        if (scored_move.move.score >= Gomoku::WINNING_SCORE)
            break;
    }
    return (sorted_updates);
}

void Gomoku::update_game_state(uint64_t *board, t_moveset &moveset, const t_update_list& update_list)
{
    t_coord new_move;

    this->update_board(board, update_list);
    for (const auto& updates: update_list)
    {
        if (updates.type == Gomoku::ADD)
        {
            moveset.erase(updates.coord);
            for (auto& factor : Gomoku::_moveset_cells)
            {
                new_move = updates.coord + factor;
                if (this->get_piece(board, new_move) == Gomoku::EMPTY)
                    moveset.insert(new_move);
            }
        }
        if (updates.type == Gomoku::REMOVE)
            moveset.insert(updates.coord);
    }    
}
void Gomoku::update_node_state(uint64_t *board, t_moveset &added_moves, t_moveset &moveset, const t_update_list& update_list)
{
    t_coord new_move;

    this->update_board(board, update_list);
    for (const auto& updates: update_list)
    {
        if (updates.type == Gomoku::ADD)
        {
            moveset.erase(updates.coord);
            for (auto& factor : Gomoku::_moveset_cells)
            {
                new_move = updates.coord + factor;
                if (this->get_piece(board, new_move) == Gomoku::EMPTY && moveset.count(new_move) == 0)
                    added_moves.insert(new_move);
            }
        }
        if (updates.type == Gomoku::REMOVE)
            added_moves.insert(updates.coord);
    }
    for (const auto& move: added_moves)
        moveset.insert(move);
}

void Gomoku::revert_node_state(uint64_t *board, t_moveset &added_moves, t_moveset &moveset, const t_update_list& update_list)
{
    this->revert_board_update(board, update_list);
    for (const auto& move: added_moves)
        moveset.erase(move);
    for (const auto& updates: update_list)
    {
        if (updates.type == Gomoku::REMOVE)
            moveset.erase(updates.coord);
        if (updates.type == Gomoku::ADD)
            moveset.insert(updates.coord);
    }
}

Gomoku::t_scored_move Gomoku::maximizer(t_moveset& moveset,
            uint64_t* board, uint8_t depth, t_prunner prunner, t_capture_count count, t_piece piece)
{
    t_moveset           added_moveset;
    t_scored_move       move_eval;
    t_scored_move       best_eval;
    uint8_t             move_couter;

    if (depth == 0)
        return (t_scored_move{t_coord{}, this->evaluate_board(board, piece)});
    best_eval = t_scored_move{t_coord{-1, -1}, INTMAX_MIN};
    move_couter = -1;
    for (auto& update: this->generate_sorted_updates(moveset, board, piece))
    {
        count.maximizer_count += update.cupture_count;
        added_moveset.clear();
        this->update_node_state(board, added_moveset, moveset, update.updates);
        if (update.move.score >= Gomoku::WINNING_SCORE|| count.maximizer_count >= MAX_CAPTURE)
        {
            best_eval = t_scored_move{update.move.coord, this->evaluate_board(board, piece)};
            this->revert_node_state(board, added_moveset, moveset, update.updates);
            break;
        }
        move_eval = this->minimizer(moveset, board, depth - 1, prunner, count, GET_OPPONENT(piece));
        this->revert_node_state(board, added_moveset, moveset, update.updates);
        if (move_eval.score >= best_eval.score)
            best_eval = t_scored_move{update.move.coord, move_eval.score};
        prunner.alpha = std::max(prunner.alpha, best_eval.score);
        if (prunner.beta <= prunner.alpha)
            break;
        if (++move_couter > 17)
            break;
    }
    return (best_eval);    
}

Gomoku::t_scored_move Gomoku::minimizer
    (t_moveset& moveset, uint64_t* board, uint8_t depth, t_prunner prunner, t_capture_count count, t_piece piece)
{
    t_moveset           added_moveset;
    t_scored_move       move_eval;
    t_scored_move       best_eval;
    uint8_t             move_couter;

    if (depth == 0)
        return (t_scored_move{t_coord{}, - this->evaluate_board(board, piece)});
    best_eval = t_scored_move{t_coord{-1, -1}, INTMAX_MAX};
    move_couter = -1;
    for (auto& update: this->generate_sorted_updates(moveset, board, piece))
    {
        added_moveset.clear();
        count.minimizer_count += update.cupture_count;
        this->update_node_state(board, added_moveset, moveset, update.updates);
        if (update.move.score >= Gomoku::WINNING_SCORE || count.maximizer_count >= MAX_CAPTURE)
        {
            best_eval = t_scored_move{update.move.coord, - this->evaluate_board(board, piece)};
            this->revert_node_state(board, added_moveset, moveset, update.updates);
            break;
        }
        move_eval = this->maximizer(moveset, board, depth - 1, prunner, count, GET_OPPONENT(piece));
        this->revert_node_state(board, added_moveset, moveset, update.updates);
        if (move_eval.score <= best_eval.score)
            best_eval = t_scored_move{update.move.coord, move_eval.score};
        prunner.beta = std::min(prunner.beta, best_eval.score);
        if (prunner.beta <= prunner.alpha)
            break;
        if (++move_couter > 17)
            break;
    }
    return (best_eval);
}

Gomoku::t_coord Gomoku::ai_move(t_player& player, t_player &opponent)
{
    uint64_t        *new_board;
    t_scored_move    best_move;

    if (_turn == 0)
        return t_coord{10, 10};
    new_board = this->copy_board(this->_move_history.front());
    auto start = std::chrono::steady_clock::now();
    best_move = this->maximizer(this->_ai_moveset,
        new_board, this->_depth,
        t_prunner{INTMAX_MIN, INTMAX_MAX},
        _capture_count, player.piece);
    auto end = std::chrono::steady_clock::now();
    auto diff = end - start;
    this->_average_time = std::chrono::duration<double>(diff).count();
    std::cout << "AI move took " << std::chrono::duration<double, std::milli>(diff).count() << " ms" << std::endl;
    return best_move.coord;
}

Gomoku::t_coord Gomoku::human_move(t_player& player, t_player &opponent)
{
    t_coord coord;

    (void)opponent;
    for (;;)
    {
        try
        {
            std::cin >> coord.x >> coord.y;
            if (this->is_move_valid(coord, player.piece))
                break;
            else
                std::cout << "Illegal move" << std::endl;
            std::cin.clear();
        }
        catch(const std::exception& e)
        {
            std::cout << "Invalid move" << '\n';
        }
        
    }
    return (coord);
}

void Gomoku::make_move(t_player& player, t_player& opponent)
{
    uint64_t        *new_board;
    t_update_list   update;
    t_coord         piece_coord;

    piece_coord = (this->*player.move)(player, opponent);
    if (piece_coord == t_coord{-1, -1})
        std::cout << "Player " << player.piece << " forfeits" << std::endl;
    else
    {
        new_board = this->copy_board(this->_move_history.front());
        this->generate_update_list(new_board, piece_coord, player.piece, update);
        this->update_game_state(new_board, this->_ai_moveset, update);
        this->_move_history.push_front(new_board);
        this->_last_move = piece_coord;
        this->_turn++;
        this->print_board();
        if (this->is_winning_move(this->_move_history.front(), player.piece, piece_coord))
        {
            std::cout << "-----------------------" << std::endl;
            std::cout << "Player " << player.piece << " wins!" << std::endl;
            std::cout << "-----------------------" << std::endl;
            std::cout << "Game took " << this->_turn << " turns" << std::endl;
            std::cout << "Average AI move time: " << this->_average_time / this->_turn << " ms" << std::endl;
            exit(1);
        }
    }
}

void Gomoku::start_game()
{
    this->print_board();
    for (;;)
    {
        this->make_move(this->_first_player, this->_second_player);
        this->make_move(this->_second_player, this->_first_player);
    }
}
int main()
{
    Gomoku game(19, Gomoku::EASY, Gomoku::EASY, Gomoku::AI, Gomoku::AI);
    game.start_game();
    return (0);
}